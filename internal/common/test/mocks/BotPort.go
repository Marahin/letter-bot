// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"spot-assistant/internal/core/dto/book"
	"spot-assistant/internal/core/dto/discord"
	"spot-assistant/internal/core/dto/guild"
	"spot-assistant/internal/core/dto/member"
	"spot-assistant/internal/core/dto/reservation"
	"spot-assistant/internal/core/dto/summary"

	mock "github.com/stretchr/testify/mock"
)

// NewMockBotPort creates a new instance of MockBotPort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBotPort(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBotPort {
	mock := &MockBotPort{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBotPort is an autogenerated mock type for the BotPort type
type MockBotPort struct {
	mock.Mock
}

type MockBotPort_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBotPort) EXPECT() *MockBotPort_Expecter {
	return &MockBotPort_Expecter{mock: &_m.Mock}
}

// FindChannelByName provides a mock function for the type MockBotPort
func (_mock *MockBotPort) FindChannelByName(g *guild.Guild, channelName string) (*discord.Channel, error) {
	ret := _mock.Called(g, channelName)

	if len(ret) == 0 {
		panic("no return value specified for FindChannelByName")
	}

	var r0 *discord.Channel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*guild.Guild, string) (*discord.Channel, error)); ok {
		return returnFunc(g, channelName)
	}
	if returnFunc, ok := ret.Get(0).(func(*guild.Guild, string) *discord.Channel); ok {
		r0 = returnFunc(g, channelName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discord.Channel)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*guild.Guild, string) error); ok {
		r1 = returnFunc(g, channelName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBotPort_FindChannelByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindChannelByName'
type MockBotPort_FindChannelByName_Call struct {
	*mock.Call
}

// FindChannelByName is a helper method to define mock.On call
//   - g *guild.Guild
//   - channelName string
func (_e *MockBotPort_Expecter) FindChannelByName(g interface{}, channelName interface{}) *MockBotPort_FindChannelByName_Call {
	return &MockBotPort_FindChannelByName_Call{Call: _e.mock.On("FindChannelByName", g, channelName)}
}

func (_c *MockBotPort_FindChannelByName_Call) Run(run func(g *guild.Guild, channelName string)) *MockBotPort_FindChannelByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *guild.Guild
		if args[0] != nil {
			arg0 = args[0].(*guild.Guild)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBotPort_FindChannelByName_Call) Return(channel *discord.Channel, err error) *MockBotPort_FindChannelByName_Call {
	_c.Call.Return(channel, err)
	return _c
}

func (_c *MockBotPort_FindChannelByName_Call) RunAndReturn(run func(g *guild.Guild, channelName string) (*discord.Channel, error)) *MockBotPort_FindChannelByName_Call {
	_c.Call.Return(run)
	return _c
}

// OpenDM provides a mock function for the type MockBotPort
func (_mock *MockBotPort) OpenDM(m *member.Member) (*discord.Channel, error) {
	ret := _mock.Called(m)

	if len(ret) == 0 {
		panic("no return value specified for OpenDM")
	}

	var r0 *discord.Channel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*member.Member) (*discord.Channel, error)); ok {
		return returnFunc(m)
	}
	if returnFunc, ok := ret.Get(0).(func(*member.Member) *discord.Channel); ok {
		r0 = returnFunc(m)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discord.Channel)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*member.Member) error); ok {
		r1 = returnFunc(m)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBotPort_OpenDM_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenDM'
type MockBotPort_OpenDM_Call struct {
	*mock.Call
}

// OpenDM is a helper method to define mock.On call
//   - m *member.Member
func (_e *MockBotPort_Expecter) OpenDM(m interface{}) *MockBotPort_OpenDM_Call {
	return &MockBotPort_OpenDM_Call{Call: _e.mock.On("OpenDM", m)}
}

func (_c *MockBotPort_OpenDM_Call) Run(run func(m *member.Member)) *MockBotPort_OpenDM_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *member.Member
		if args[0] != nil {
			arg0 = args[0].(*member.Member)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBotPort_OpenDM_Call) Return(channel *discord.Channel, err error) *MockBotPort_OpenDM_Call {
	_c.Call.Return(channel, err)
	return _c
}

func (_c *MockBotPort_OpenDM_Call) RunAndReturn(run func(m *member.Member) (*discord.Channel, error)) *MockBotPort_OpenDM_Call {
	_c.Call.Return(run)
	return _c
}

// Run provides a mock function for the type MockBotPort
func (_mock *MockBotPort) Run() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Run")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBotPort_Run_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Run'
type MockBotPort_Run_Call struct {
	*mock.Call
}

// Run is a helper method to define mock.On call
func (_e *MockBotPort_Expecter) Run() *MockBotPort_Run_Call {
	return &MockBotPort_Run_Call{Call: _e.mock.On("Run")}
}

func (_c *MockBotPort_Run_Call) Run(run func()) *MockBotPort_Run_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockBotPort_Run_Call) Return(err error) *MockBotPort_Run_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBotPort_Run_Call) RunAndReturn(run func() error) *MockBotPort_Run_Call {
	_c.Call.Return(run)
	return _c
}

// SendDMOverbookedNotification provides a mock function for the type MockBotPort
func (_mock *MockBotPort) SendDMOverbookedNotification(member1 *member.Member, request book.BookRequest, res *reservation.ClippedOrRemovedReservation) error {
	ret := _mock.Called(member1, request, res)

	if len(ret) == 0 {
		panic("no return value specified for SendDMOverbookedNotification")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*member.Member, book.BookRequest, *reservation.ClippedOrRemovedReservation) error); ok {
		r0 = returnFunc(member1, request, res)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBotPort_SendDMOverbookedNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendDMOverbookedNotification'
type MockBotPort_SendDMOverbookedNotification_Call struct {
	*mock.Call
}

// SendDMOverbookedNotification is a helper method to define mock.On call
//   - member1 *member.Member
//   - request book.BookRequest
//   - res *reservation.ClippedOrRemovedReservation
func (_e *MockBotPort_Expecter) SendDMOverbookedNotification(member1 interface{}, request interface{}, res interface{}) *MockBotPort_SendDMOverbookedNotification_Call {
	return &MockBotPort_SendDMOverbookedNotification_Call{Call: _e.mock.On("SendDMOverbookedNotification", member1, request, res)}
}

func (_c *MockBotPort_SendDMOverbookedNotification_Call) Run(run func(member1 *member.Member, request book.BookRequest, res *reservation.ClippedOrRemovedReservation)) *MockBotPort_SendDMOverbookedNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *member.Member
		if args[0] != nil {
			arg0 = args[0].(*member.Member)
		}
		var arg1 book.BookRequest
		if args[1] != nil {
			arg1 = args[1].(book.BookRequest)
		}
		var arg2 *reservation.ClippedOrRemovedReservation
		if args[2] != nil {
			arg2 = args[2].(*reservation.ClippedOrRemovedReservation)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBotPort_SendDMOverbookedNotification_Call) Return(err error) *MockBotPort_SendDMOverbookedNotification_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBotPort_SendDMOverbookedNotification_Call) RunAndReturn(run func(member1 *member.Member, request book.BookRequest, res *reservation.ClippedOrRemovedReservation) error) *MockBotPort_SendDMOverbookedNotification_Call {
	_c.Call.Return(run)
	return _c
}

// SendLetterMessage provides a mock function for the type MockBotPort
func (_mock *MockBotPort) SendLetterMessage(g *guild.Guild, ch *discord.Channel, sum *summary.Summary) error {
	ret := _mock.Called(g, ch, sum)

	if len(ret) == 0 {
		panic("no return value specified for SendLetterMessage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*guild.Guild, *discord.Channel, *summary.Summary) error); ok {
		r0 = returnFunc(g, ch, sum)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBotPort_SendLetterMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendLetterMessage'
type MockBotPort_SendLetterMessage_Call struct {
	*mock.Call
}

// SendLetterMessage is a helper method to define mock.On call
//   - g *guild.Guild
//   - ch *discord.Channel
//   - sum *summary.Summary
func (_e *MockBotPort_Expecter) SendLetterMessage(g interface{}, ch interface{}, sum interface{}) *MockBotPort_SendLetterMessage_Call {
	return &MockBotPort_SendLetterMessage_Call{Call: _e.mock.On("SendLetterMessage", g, ch, sum)}
}

func (_c *MockBotPort_SendLetterMessage_Call) Run(run func(g *guild.Guild, ch *discord.Channel, sum *summary.Summary)) *MockBotPort_SendLetterMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *guild.Guild
		if args[0] != nil {
			arg0 = args[0].(*guild.Guild)
		}
		var arg1 *discord.Channel
		if args[1] != nil {
			arg1 = args[1].(*discord.Channel)
		}
		var arg2 *summary.Summary
		if args[2] != nil {
			arg2 = args[2].(*summary.Summary)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBotPort_SendLetterMessage_Call) Return(err error) *MockBotPort_SendLetterMessage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBotPort_SendLetterMessage_Call) RunAndReturn(run func(g *guild.Guild, ch *discord.Channel, sum *summary.Summary) error) *MockBotPort_SendLetterMessage_Call {
	_c.Call.Return(run)
	return _c
}
